{
  "title": "Vitest 2.0 変更まとめ",
  "closed": false,
  "archived": false,
  "created_at": "2024-07-25",
  "comments": [
    {
      "author": "caffe_latte_623",
      "created_at": "2024-07-25",
      "body_markdown": "Vitestのv2.0.0がいつの間にか出ていたので変更内容をまとめていく\n\nhttps://github.com/vitest-dev/vitest/releases/tag/v2.0.0\n\nhttps://vitest.dev/guide/migration.html",
      "body_updated_at": "2024-07-25"
    },
    {
      "author": "caffe_latte_623",
      "created_at": "2024-07-25",
      "body_markdown": "# Breaking Change\n## `pool`のデフォルト値が`forks`に変更\n1.x系ではデフォルト値が`threads`だった。\n`threads`と`pool`の違いは内部的に使用している[tinypool](https://github.com/tinylibs/tinypool)のメソッドを`worker_threads`の代わりに`child_process`を使用している点。\n\npoolを指定しないでpoolOptionsを設定している場合は影響がある。\n```diff ts\nexport default defineConfig({\n  test: {\n    poolOptions: {\n-      threads: { \n-       singleThread: true, \n-     }, \n+     forks: { \n+      singleFork: true, \n+    }, \n    }\n  }\n})\n```\n\n## フックがスタックで実行される\nv2.0以前はフックが並列で実行されていたが、直列で実行されるように変更。\nこちらも`sequence.hooks`のデフォルト値が`parallel`から`stack`に変更された。\n`stack`に変更されることで`afterAll`/`afterEach`の実行順に影響があるらしい。\n\n例) \n```ts\nimport { afterAll, test, expect } from \"vitest\";\n\nafterAll(() => {\n  console.log(\"afterAll 1\");\n});\n\nafterAll(() => {\n  console.log(\"afterAll 2\");\n});\n\ntest(\"1\", () => {\n  expect(1 + 1).toBe(2);\n});\n```\n- `sequence.hooks = \"parallel\"`の場合\n![](https://storage.googleapis.com/zenn-user-upload/e4fee1f77c90-20240725.png)\n\n- `sequence.hooks = \"stack\"`の場合\n![](https://storage.googleapis.com/zenn-user-upload/cc591ac22cec-20240725.png)\n\n\n## `suite.concurrent`ですべてのテストが同時実行されるようになる\n以前は特定のスイートごとに同時実行され、スイートは順番に実行されていたが、Jestの仕様に倣って全テストが同時実行されるようになる。(同時実行数自体は`maxConcurrency`で指定可能)\n\n## `coverage.ignoreEmptyLines`がデフォルトで有効に\nesbuildだとトランスパイルされるときにTypescriptの型とかコメントが削除されるけど、それを無視するようにする設定。\n\n## `watchExclude`オプションが削除\n`server.watch.ignored`に置き換わり。\n\n## `--segfault-retry`の削除\n`pool`のデフォルト値が変更になったため、必要なくなった。\n\n## JSONレポーターで`task.meta`が出力されるように変更\n```diff:json\n{\n  ..., \n  \"testResults\": [\n    {\n      \"assertionResults\": [\n        {\n          \"ancestorTitles\": [],\n          \"fullName\": \"1\",\n          \"status\": \"passed\",\n          \"title\": \"1\",\n          \"duration\": 1,\n          \"failureMessages\": [],\n+          \"meta\": { \"custom\": \"sampe-meta\" }\n        }\n      ],\n      \"startTime\": 1721891818124,\n      \"endTime\": 1721891818125,\n      \"status\": \"passed\",\n      \"message\": \"\",\n      \"name\": \"...\"\n    }\n  ]\n}\n```\n\n## モック関数の型定義の簡略化\n`vi.fn`や`Mock`などのモック関数の型定義としてパラメータと返却値をそれぞれジェネリクスで渡す必要があったが、関数の型だけを渡せばよくなった。\n```diff:ts\nimport { type Mock, vi } from 'vitest'\n\nconst add = (x: number, y: number): number => x + y\n\n// using vi.fn<T>\n\nconst mockAdd = vi.fn<typeof add>() \n\n// using Mock<T>\n\nconst mockAdd: Mock<typeof add> = vi.fn() \n```\n\n## Resolveされた`mocks.result`へのアクセス方法の変更\n以前はモック関数がPromiseを返却したとき、`mock.results`はResolveされた型を返却していた。\n新たにPromiseの結果を持つ`mock.settledResults`が追加され、Resolveされた型を返却する。\n(`mock.results`はPromise型を返却する)\n\n```diff:ts\nconst fn = vi.fn().mockResolvedValueOnce('result')\nawait fn()\n\n- const result = fn.mock.results[0] // 'result'\n+ const result = fn.mock.results[0] // 'Promise<result>'\n\nconst settledResult = fn.mock.settledResults[0] // 'result'\n```\n\nこれに関連して新規に`toHaveResolved`が追加される\n```diff:ts\nconst fn = vi.fn().mockResolvedValueOnce('result')\nawait fn()\n\n- expect(fn).toHaveReturned('result') \n+ expect(fn).toHaveResolved('result') \n```\n\n## ブラウザモード\n- `none`プロバイダーが`preview`にリネーム\n- `preview`プロバイダーがデフォルト値\n- `indexScripts`が`orchestratorScripts`にリネーム\n\n## Deprecated\n- `vitest typecheck`コマンド\n    - `vitest --typecheck`に変更\n- `VITEST_JUNIT_CLASSNAME`と`VITEST_JUNIT_SUITE_NAME`の環境変数\n    - レポーターのオプションで設定する\n- `c8`のカバレッジチェック\n    - `coverage-v8`を代わりに使用する\n- `SnapshotEnvironment`の`vitest`からのexport\n    - `vitest/snapshot`からインポートできる\n- `SpyInstance`\n    - `MockInstance`を使用\n\n",
      "body_updated_at": "2024-07-25"
    }
  ]
}